// automatically generated by the FlatBuffers compiler, do not modify

#![allow(dead_code)]
#![allow(unused_imports)]
extern crate flatbuffers;

pub mod example {
    #![allow(dead_code)]
    #![allow(unused_imports)]

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::EndianScalar;

    #[allow(non_camel_case_types)]
    #[repr(i16)]
    #[derive(Clone, Copy, PartialEq, Debug)]
    pub enum Language {
        Rust = 0,
        Python = 1,
    }

    const ENUM_MIN_LANGUAGE: i16 = 0;
    const ENUM_MAX_LANGUAGE: i16 = 1;

    impl<'a> flatbuffers::Follow<'a> for Language {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for Language {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = i16::to_le(self as i16);
            let p = &n as *const i16 as *const Language;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = i16::from_le(self as i16);
            let p = &n as *const i16 as *const Language;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for Language {
        type Output = Language;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<Language>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    const ENUM_VALUES_LANGUAGE: [Language; 2] = [Language::Rust, Language::Python];

    #[allow(non_camel_case_types)]
    const ENUM_NAMES_LANGUAGE: [&'static str; 2] = ["Rust", "Python"];

    pub fn enum_name_language(e: Language) -> &'static str {
        let index: usize = e as usize;
        ENUM_NAMES_LANGUAGE[index]
    }

    #[allow(non_camel_case_types)]
    #[repr(u8)]
    #[derive(Clone, Copy, PartialEq, Debug)]
    pub enum CodeOption {
        NONE = 0,
        Code = 1,
    }

    const ENUM_MIN_CODE_OPTION: u8 = 0;
    const ENUM_MAX_CODE_OPTION: u8 = 1;

    impl<'a> flatbuffers::Follow<'a> for CodeOption {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for CodeOption {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = u8::to_le(self as u8);
            let p = &n as *const u8 as *const CodeOption;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = u8::from_le(self as u8);
            let p = &n as *const u8 as *const CodeOption;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for CodeOption {
        type Output = CodeOption;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<CodeOption>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    const ENUM_VALUES_CODE_OPTION: [CodeOption; 2] = [CodeOption::NONE, CodeOption::Code];

    #[allow(non_camel_case_types)]
    const ENUM_NAMES_CODE_OPTION: [&'static str; 2] = ["NONE", "Code"];

    pub fn enum_name_code_option(e: CodeOption) -> &'static str {
        let index: usize = e as usize;
        ENUM_NAMES_CODE_OPTION[index]
    }

    pub struct CodeOptionUnionTableOffset {}
    // struct Scalars, aligned to 8
    #[repr(C, align(8))]
    #[derive(Clone, Copy, Debug, PartialEq)]
    pub struct Scalars {
        a_byte_: i8,
        a_ubyte_: u8,
        a_bool_: bool,
        padding0__: u8,
        a_short_: i16,
        a_ushort_: u16,
        a_int_: i32,
        a_uint_: u32,
        a_float_: f32,
        padding1__: u32,
        a_long_: i64,
        a_ulong_: u64,
        a_double_: f64,
    } // pub struct Scalars
    impl flatbuffers::SafeSliceAccess for Scalars {}
    impl<'a> flatbuffers::Follow<'a> for Scalars {
        type Inner = &'a Scalars;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a Scalars>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Scalars {
        type Inner = &'a Scalars;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<Scalars>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for Scalars {
        type Output = Scalars;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(self as *const Scalars as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }
    impl<'b> flatbuffers::Push for &'b Scalars {
        type Output = Scalars;

        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(*self as *const Scalars as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }

    impl Scalars {
        pub fn new<'a>(
            _a_byte: i8,
            _a_ubyte: u8,
            _a_bool: bool,
            _a_short: i16,
            _a_ushort: u16,
            _a_int: i32,
            _a_uint: u32,
            _a_float: f32,
            _a_long: i64,
            _a_ulong: u64,
            _a_double: f64,
        ) -> Self {
            Scalars {
                a_byte_: _a_byte.to_little_endian(),
                a_ubyte_: _a_ubyte.to_little_endian(),
                a_bool_: _a_bool.to_little_endian(),
                a_short_: _a_short.to_little_endian(),
                a_ushort_: _a_ushort.to_little_endian(),
                a_int_: _a_int.to_little_endian(),
                a_uint_: _a_uint.to_little_endian(),
                a_float_: _a_float.to_little_endian(),
                a_long_: _a_long.to_little_endian(),
                a_ulong_: _a_ulong.to_little_endian(),
                a_double_: _a_double.to_little_endian(),

                padding0__: 0,
                padding1__: 0,
            }
        }
        pub fn a_byte<'a>(&'a self) -> i8 {
            self.a_byte_.from_little_endian()
        }
        pub fn a_ubyte<'a>(&'a self) -> u8 {
            self.a_ubyte_.from_little_endian()
        }
        pub fn a_bool<'a>(&'a self) -> bool {
            self.a_bool_.from_little_endian()
        }
        pub fn a_short<'a>(&'a self) -> i16 {
            self.a_short_.from_little_endian()
        }
        pub fn a_ushort<'a>(&'a self) -> u16 {
            self.a_ushort_.from_little_endian()
        }
        pub fn a_int<'a>(&'a self) -> i32 {
            self.a_int_.from_little_endian()
        }
        pub fn a_uint<'a>(&'a self) -> u32 {
            self.a_uint_.from_little_endian()
        }
        pub fn a_float<'a>(&'a self) -> f32 {
            self.a_float_.from_little_endian()
        }
        pub fn a_long<'a>(&'a self) -> i64 {
            self.a_long_.from_little_endian()
        }
        pub fn a_ulong<'a>(&'a self) -> u64 {
            self.a_ulong_.from_little_endian()
        }
        pub fn a_double<'a>(&'a self) -> f64 {
            self.a_double_.from_little_endian()
        }
    }

    pub enum ExampleOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Example<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Example<'a> {
        type Inner = Example<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Example<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Example { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ExampleArgs<'args>,
        ) -> flatbuffers::WIPOffset<Example<'bldr>> {
            let mut builder = ExampleBuilder::new(_fbb);
            builder.add_lines(args.lines);
            if let Some(x) = args.blocks {
                builder.add_blocks(x);
            }
            if let Some(x) = args.scalars {
                builder.add_scalars(x);
            }
            builder.add_version(args.version);
            builder.add_language(args.language);
            builder.finish()
        }

        pub const VT_VERSION: flatbuffers::VOffsetT = 4;
        pub const VT_LANGUAGE: flatbuffers::VOffsetT = 6;
        pub const VT_SCALARS: flatbuffers::VOffsetT = 8;
        pub const VT_BLOCKS: flatbuffers::VOffsetT = 12;
        pub const VT_LINES: flatbuffers::VOffsetT = 14;

        #[inline]
        pub fn version(&self) -> u32 {
            self._tab.get::<u32>(Example::VT_VERSION, Some(0)).unwrap()
        }
        #[inline]
        pub fn language(&self) -> Language {
            self._tab
                .get::<Language>(Example::VT_LANGUAGE, Some(Language::Rust))
                .unwrap()
        }
        #[inline]
        pub fn scalars(&self) -> Option<&'a Scalars> {
            self._tab.get::<Scalars>(Example::VT_SCALARS, None)
        }
        #[inline]
        pub fn blocks(
            &self,
        ) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Block<'a>>>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<flatbuffers::ForwardsUOffset<Block<'a>>>,
            >>(Example::VT_BLOCKS, None)
        }
        #[inline]
        pub fn lines(&self) -> u32 {
            self._tab.get::<u32>(Example::VT_LINES, Some(0)).unwrap()
        }
    }

    pub struct ExampleArgs<'a> {
        pub version: u32,
        pub language: Language,
        pub scalars: Option<&'a Scalars>,
        pub blocks: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Block<'a>>>,
            >,
        >,
        pub lines: u32,
    }
    impl<'a> Default for ExampleArgs<'a> {
        #[inline]
        fn default() -> Self {
            ExampleArgs {
                version: 0,
                language: Language::Rust,
                scalars: None,
                blocks: None,
                lines: 0,
            }
        }
    }
    pub struct ExampleBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ExampleBuilder<'a, 'b> {
        #[inline]
        pub fn add_version(&mut self, version: u32) {
            self.fbb_.push_slot::<u32>(Example::VT_VERSION, version, 0);
        }
        #[inline]
        pub fn add_language(&mut self, language: Language) {
            self.fbb_
                .push_slot::<Language>(Example::VT_LANGUAGE, language, Language::Rust);
        }
        #[inline]
        pub fn add_scalars(&mut self, scalars: &'b Scalars) {
            self.fbb_
                .push_slot_always::<&Scalars>(Example::VT_SCALARS, scalars);
        }
        #[inline]
        pub fn add_blocks(
            &mut self,
            blocks: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Block<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Example::VT_BLOCKS, blocks);
        }
        #[inline]
        pub fn add_lines(&mut self, lines: u32) {
            self.fbb_.push_slot::<u32>(Example::VT_LINES, lines, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExampleBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ExampleBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Example<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum CodeOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Code<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Code<'a> {
        type Inner = Code<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Code<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Code { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CodeArgs<'args>,
        ) -> flatbuffers::WIPOffset<Code<'bldr>> {
            let mut builder = CodeBuilder::new(_fbb);
            if let Some(x) = args.bytes {
                builder.add_bytes(x);
            }
            builder.finish()
        }

        pub const VT_BYTES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn bytes(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Code::VT_BYTES,
                    None,
                ).map(|v| v.safe_slice())
        }
    }

    pub struct CodeArgs<'a> {
        pub bytes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for CodeArgs<'a> {
        #[inline]
        fn default() -> Self {
            CodeArgs { bytes: None }
        }
    }
    pub struct CodeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CodeBuilder<'a, 'b> {
        #[inline]
        pub fn add_bytes(&mut self, bytes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Code::VT_BYTES, bytes);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CodeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CodeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Code<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum AuthorOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Author<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Author<'a> {
        type Inner = Author<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Author<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Author { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args AuthorArgs<'args>,
        ) -> flatbuffers::WIPOffset<Author<'bldr>> {
            let mut builder = AuthorBuilder::new(_fbb);
            builder.add_birth(args.birth);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_BIRTH: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Author::VT_NAME, None)
        }
        #[inline]
        pub fn birth(&self) -> u32 {
            self._tab.get::<u32>(Author::VT_BIRTH, Some(0)).unwrap()
        }
    }

    pub struct AuthorArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub birth: u32,
    }
    impl<'a> Default for AuthorArgs<'a> {
        #[inline]
        fn default() -> Self {
            AuthorArgs {
                name: None,
                birth: 0,
            }
        }
    }
    pub struct AuthorBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> AuthorBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Author::VT_NAME, name);
        }
        #[inline]
        pub fn add_birth(&mut self, birth: u32) {
            self.fbb_.push_slot::<u32>(Author::VT_BIRTH, birth, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AuthorBuilder<'a, 'b> {
            let start = _fbb.start_table();
            AuthorBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Author<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum BlockOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Block<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Block<'a> {
        type Inner = Block<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Block<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Block { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BlockArgs<'args>,
        ) -> flatbuffers::WIPOffset<Block<'bldr>> {
            let mut builder = BlockBuilder::new(_fbb);
            if let Some(x) = args.code {
                builder.add_code(x);
            }
            if let Some(x) = args.author {
                builder.add_author(x);
            }
            builder.add_code_type(args.code_type);
            builder.finish()
        }

        pub const VT_AUTHOR: flatbuffers::VOffsetT = 4;
        pub const VT_CODE_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_CODE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn author(&self) -> Option<Author<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Author<'a>>>(Block::VT_AUTHOR, None)
        }
        #[inline]
        pub fn code_type(&self) -> CodeOption {
            self._tab
                .get::<CodeOption>(Block::VT_CODE_TYPE, Some(CodeOption::NONE))
                .unwrap()
        }
        #[inline]
        pub fn code(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Block::VT_CODE, None)
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn code_as_code(&'a self) -> Option<Code> {
            if self.code_type() == CodeOption::Code {
                self.code().map(|u| Code::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct BlockArgs<'a> {
        pub author: Option<flatbuffers::WIPOffset<Author<'a>>>,
        pub code_type: CodeOption,
        pub code: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for BlockArgs<'a> {
        #[inline]
        fn default() -> Self {
            BlockArgs {
                author: None,
                code_type: CodeOption::NONE,
                code: None,
            }
        }
    }
    pub struct BlockBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BlockBuilder<'a, 'b> {
        #[inline]
        pub fn add_author(&mut self, author: flatbuffers::WIPOffset<Author<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Author>>(Block::VT_AUTHOR, author);
        }
        #[inline]
        pub fn add_code_type(&mut self, code_type: CodeOption) {
            self.fbb_
                .push_slot::<CodeOption>(Block::VT_CODE_TYPE, code_type, CodeOption::NONE);
        }
        #[inline]
        pub fn add_code(&mut self, code: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Block::VT_CODE, code);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BlockBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Block<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    #[inline]
    pub fn get_root_as_example<'a>(buf: &'a [u8]) -> Example<'a> {
        flatbuffers::get_root::<Example<'a>>(buf)
    }

    #[inline]
    pub fn get_size_prefixed_root_as_example<'a>(buf: &'a [u8]) -> Example<'a> {
        flatbuffers::get_size_prefixed_root::<Example<'a>>(buf)
    }

    #[inline]
    pub fn finish_example_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Example<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_example_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Example<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod example
